import { serve } from 'https://deno.land/std@0.131.0/http/server.ts';
import { corsHeaders } from '../_shared/cors.ts';

// Define timeout duration in milliseconds (2 minutes)
const TIMEOUT_DURATION = 120000;

serve(async (req) => {
  // Handle CORS for browser requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  
  try {
    // Parse request body
    const requestData = await req.json();
    
    // Store user id if available for authentication
    const userId = requestData.user_id;
    
    // For resuming after auth - store metadata
    const authContext = {
      resumable: true,
      formData: requestData,
      timestamp: Date.now()
    };
    
    // Generate response with timeout logic
    const responseData = await generateWithTimeout(requestData);
    
    // Return the generated recipe
    return new Response(
      JSON.stringify({
        ...responseData,
        auth_context: authContext
      }),
      { 
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 200
      }
    );
  } catch (error) {
    // Handle errors
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    const statusCode = errorMessage.includes('timeout') ? 408 : 500;
    
    return new Response(
      JSON.stringify({
        error: errorMessage,
        isError: true,
        status: statusCode
      }),
      { 
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: statusCode
      }
    );
  }
});

// Helper function to generate recipe with timeout protection
async function generateWithTimeout(requestData) {
  const { ingredients, max_calories, allowed_time } = requestData;

  // Construct the prompt
  let prompt = `Generate a quick recipe based on the following ingredients: ${ingredients.join(', ')}.`;
  if (max_calories) {
    prompt += ` The recipe should have no more than ${max_calories} calories.`;
  }
  prompt += " Provide the recipe title, a list of ingredients with quantities, and numbered steps to prepare the dish.";

  // Set up the request to OpenAI
  const openaiUrl = 'https://api.openai.com/v1/chat/completions';
  const openaiApiKey = Deno.env.get('OPENAI_API_KEY');

  if (!openaiApiKey) {
    throw new Error('OpenAI API key is missing.');
  }

  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    console.log('Timeout occurred');
    controller.abort();
  }, allowed_time || TIMEOUT_DURATION);

  try {
    const openaiResponse = await fetch(openaiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${openaiApiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
        max_tokens: 1000,
        n: 1,
        stop: null,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!openaiResponse.ok) {
      console.error('OpenAI API error:', openaiResponse.status, openaiResponse.statusText);
      const errorDetails = await openaiResponse.text();
      throw new Error(`OpenAI API request failed with status ${openaiResponse.status}: ${errorDetails}`);
    }

    const openaiData = await openaiResponse.json();

    if (!openaiData.choices || openaiData.choices.length === 0) {
      throw new Error('No recipe generated by OpenAI.');
    }

    const recipeText = openaiData.choices[0].message.content.trim();

    // Parse the generated recipe text
    const recipe = parseRecipe(recipeText);
    
    // Return the generated recipe
    return recipe;
  } catch (error) {
    clearTimeout(timeoutId);
    console.error('Error generating recipe:', error);
    throw error;
  }
}

function parseRecipe(recipeText: string) {
    const recipe: { title: string; ingredients: string[]; steps: string[] } = {
        title: '',
        ingredients: [],
        steps: []
    };

    const lines = recipeText.split('\n').map(line => line.trim()).filter(line => line !== '');

    let i = 0;

    // Extract title
    if (i < lines.length) {
        recipe.title = lines[i++];
    }

    // Extract ingredients
    while (i < lines.length && !lines[i].toLowerCase().startsWith('step')) {
        recipe.ingredients.push(lines[i++]);
    }

    // Extract steps
    while (i < lines.length) {
        if (lines[i].toLowerCase().startsWith('step')) {
            recipe.steps.push(lines[i]);
            i++;
        } else {
            i++;
        }
    }

    return recipe;
}
